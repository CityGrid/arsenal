#!/usr/bin/python
#
#  Copyright 2015 CityGrid Media, LLC
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
import os
import sys
import subprocess
import re
import logging
import argparse
import ConfigParser
import json
import yaml
import collections
import textwrap
import getpass
import ast
import requests

log = logging.getLogger(__name__)
# requests is chatty
logging.getLogger("requests").setLevel(logging.WARNING)
# FIXME: ssl issues
requests.packages.urllib3.disable_warnings()
session = requests.session()

class Node(object):
    def __init__(self,
                 register = False,
                 unique_id = None,
                 node_name = None,
                 puppet_version = None,
                 facter_version = None,
                 uptime = None,
                 ec2 = None,
                 network = None):
        self.register = register
        self.unique_id = unique_id
        self.node_name = node_name
        self.puppet_version = puppet_version
        self.facter_version = facter_version
        self.hardware_profile = HardwareProfile()
        self.operating_system = OperatingSystem()
        self.uptime = uptime
        self.ec2 = ec2
        self.network = network
 

class Ec2(object):
    def __init__(self, 
                 ec2_instance_id = None,
                 ec2_ami_id = None,
                 ec2_hostname = None,
                 ec2_public_hostname = None,
                 ec2_instance_type = None,
                 ec2_security_groups = None,
                 ec2_placement_availability_zone = None):
        self.ec2_instance_id = ec2_instance_id
        self.ec2_ami_id = ec2_ami_id
        self.ec2_hostname = ec2_hostname
        self.ec2_public_hostname = ec2_public_hostname
        self.ec2_instance_type = ec2_instance_type
        self.ec2_security_groups = ec2_security_groups
        self.ec2_placement_availability_zone = ec2_placement_availability_zone
 

class HardwareProfile(object):
    def __init__(self,
                 manufacturer = 'Unknown',
                 model = 'Unknown'):
        self.manufacturer = manufacturer
        self.model = model


class OperatingSystem(object):
    def __init__(self,
                 variant = 'Unknown',
                 version_number = 'Unknown',
                 architecture = 'Unknown',
                 description = 'Unknown'):
        self.variant = variant
        self.version_number = version_number
        self.architecture = architecture
        self.description = description


class NodeGroup(object):
    def __init__(self,
                 node_group_name = None,
                 node_group_owner = None,
                 description = None):
        self.node_group_name = node_group_name
        self.node_group_owner = node_group_owner
        self.description = description


class Network(object):
    def __init__(self,
                 interface = None,
                 mac_addr = None):
        self.interface = interface
        self.mac_addr = mac_addr


def facter():
    # need this for custom facts - can add additional paths if needed
    os.environ["FACTERLIB"] = "/var/lib/puppet/lib/facter"
    p = subprocess.Popen( ['facter'], stdout=subprocess.PIPE )
    p.wait()
    lines = p.stdout.readlines()
    lines = dict(k.split(' => ') for k in
                   [s.strip() for s in lines if ' => ' in s])
    
    return lines


def get_cookie_auth():
    try:
        cookies = read_cookie()
        if not cookies:
            cookies = authenticate()
        else:
            cookies = ast.literal_eval(cookies)

        return cookies

    except Exception, e:
        logging.error('Failed: %s' % e)


def read_cookie():
    log.debug('Checking for cookie file: %s' % (cookie_file))
    if os.path.isfile(cookie_file):
        log.debug('Cookie file found: %s' % (cookie_file))
        with open(cookie_file, 'r') as contents:
            cookies = contents.read()
        return cookies
    else:
        log.debug('Cookie file does not exist: %s' % (cookie_file))
        return None


def write_cookie(cookies):
    log.info('Writing cookie file: %s' % (cookie_file))

    try:
        cd = dict(cookies)
        with open(cookie_file, "w") as cf:
            cf.write(str(cd))
        os.chmod(cookie_file, 0600)
    except Exception, e:
        logging.error('Unable to write cookie: %s' % cookie_file)
        logging.error('Exception: %s' % e)

    return True


def authenticate():
    log.info('Authenticating login: %s' % (login))
    if login == 'kaboom':
        password = kaboom_password
    else:
        password = getpass.getpass('password: ')

    try:
        payload = {'form.submitted': True,
                   'api.client': True,
                   'return_url': '/api',
                   'login': login,
                   'password': password
        }
        r = session.post(api_protocol
                         + '://'
                         + api_host
                         + '/login', data=payload)

        if r.status_code == requests.codes.ok:

            cookies = session.cookies.get_dict()
            log.info('Cookies are: %s' %(cookies))
            try:
                write_cookie(cookies)
                return cookies
            except Exception, e:
                logging.error('Exception: %s' % e)

        else:
            log.error('Authentication failed')
            sys.exit(1)

    except Exception, e:
        logging.error('Exception: %s' % e)
        log.error('Authentication failed')
        sys.exit(1)


def api_submit(request, data=None,  method='get'):

    headers = {'content-type': 'application/json'}

    api_url = (api_protocol
               + '://'
               + api_host
               + request)

    if method == 'put':

        data = json.dumps(data, default=lambda o: o.__dict__)
        cookies = get_cookie_auth()

        log.debug('Submitting data to API: %s' % api_url)

        r = session.put(api_url, verify=verify_ssl, cookies=cookies, headers=headers, data=data)

        # re-auth if our cookie is invalid/expired
        if r.status_code == requests.codes.unauthorized:
            cookies = authenticate()
            r = session.put(api_url, verify=verify_ssl, cookies=cookies, headers=headers, data=data)

        if r.status_code == requests.codes.ok:
            print "Command successful."
        elif r.status_code == requests.codes.forbidden:
            print "Authorization failed."
        else:
            print "Command failed."
    elif method == 'delete':

        data = json.dumps(data, default=lambda o: o.__dict__)
        cookies = get_cookie_auth()

        log.debug('Deleting data from API: %s' % api_url)

        r = session.delete(api_url, verify=verify_ssl, cookies=cookies, headers=headers, data=data)

        # re-auth if our cookie is invalid/expired
        if r.status_code == requests.codes.unauthorized:
            cookies = authenticate()
            r = session.delete(api_url, verify=verify_ssl, cookies=cookies)

        if r.status_code == requests.codes.ok:
            print "Command successful."

        elif r.status_code == requests.codes.forbidden:
            print "Authorization failed."
        else:
            print "Command failed."
    elif method == 'get_params':
        r = session.get(api_url, verify=verify_ssl, params=data)
        return r.json()

    else:
        r = session.get(api_url, verify=verify_ssl)
        return r.json()


def get_unique_id(**facts):
    log.info('determining unique_id...')
    if facts['kernel'] == 'Linux' or facts['kernel'] == 'FreeBSD':
        if 'ec2_instance_id' in facts:
            unique_id = facts['ec2_instance_id']
            log.info('unique_id is from ec2_instance_id: {0}'.format(unique_id))
        elif os.path.isfile('/usr/sbin/dmidecode'):
            unique_id = get_uuid()
            if unique_id:
                log.info('unique_id is from dmidecode: {0}'.format(unique_id))
            else:
                unique_id = facts['macaddress']
                log.info('unique_id is from mac address: {0}'.format(unique_id))
        else:
            unique_id = facts['macaddress']
            log.info('unique_id is from mac address: {0}'.format(unique_id))
    else:
        unique_id = facts['macaddress']
        log.info('unique_id is from mac address: {0}'.format(unique_id))
    return unique_id


def get_uuid():
    p = subprocess.Popen( ['/usr/sbin/dmidecode', '-s', 'system-uuid'], stdout=subprocess.PIPE )
    p.wait()
    uuid = p.stdout.readlines()
    # FIXME: Need some validation here
    if uuid:
        return uuid[0].rstrip()

    return None


def get_hardware_profile(facts):
    log.info('Collecting hardware profile data.')
    hardware_profile = HardwareProfile()
    try:
        hardware_profile.manufacturer = facts['manufacturer']
        hardware_profile.model = facts['productname']
        log.info('Hardware profile from dmidecode.')
    except KeyError:
        try:
            xen_match = "xen"
            if re.match(xen_match, facts['virtual']) and facts['is_virtual'] == 'true':
                hardware_profile.manufacturer = 'Citrix'
                hardware_profile.model = 'Xen Guest'
                log.info('Hardware profile is virtual.')
        except KeyError:
            log.error('Unable to determine hardware profile.')
    return hardware_profile


def get_operating_system(facts):
    log.info('Collecting operating_system data.')
    operating_system = OperatingSystem()
    try:
        operating_system.variant = facts['operatingsystem']
        operating_system.version_number = facts['operatingsystemrelease']
        operating_system.architecture = facts['architecture']
        operating_system.description = facts['lsbdistdescription']
    except KeyError:
        log.error('Unable to determine operating system.')

    return operating_system


def collect_data():
    log.info('Collecting data for node.')
    data = Node()
    facts = facter()
    unique_id = get_unique_id(**facts)
    data.unique_id = unique_id

    # EC2 facts
    if 'ec2_instance_id' in facts:
        ec2 = Ec2()
        ec2.ec2_instance_id = facts['ec2_instance_id']
        ec2.ec2_ami_id = facts['ec2_ami_id']
        ec2.ec2_hostname = facts['ec2_hostname']
        ec2.ec2_public_hostname = facts['ec2_public_hostname']
        ec2.ec2_instance_type = facts['ec2_instance_type']
        ec2.ec2_security_groups = facts['ec2_security_groups']
        ec2.ec2_placement_availability_zone = facts['ec2_placement_availability_zone']
        data.ec2 = ec2

    # puppet & facter versions
    if 'puppetversion' in facts:
        data.puppet_version = facts['puppetversion'] 
        data.facter_version = facts['facterversion']

    # Report uptime
    data.uptime = facts['uptime']

    data.hardware_profile = get_hardware_profile(facts)

    data.operating_system = get_operating_system(facts)

#    data[operating_system[version_number]] = facts['lsbdistrelease']

    #
    # Gather software-related information
    #
    # Use our custom fact for aws. Required since hostname -f
    # doens't work on ec2 hosts.
    # FIXME: need regex match
    if 'ct_fqdn' in facts and facts['ct_loc'] == 'aws1':
       data.node_name = facts['ct_fqdn']
    else:
       data.node_name = facts['fqdn']

    return data


def ask_yes_no(question, answer_yes=None, default='no'):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """

    if answer_yes:
        return True

    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")

## NODES
def _register(args):
        """Collect all the data about a node and register
           it with the server"""

        data = collect_data()
        data.register = True

        log.info('data is: {0}'.format(json.dumps(data, default=lambda o: o.__dict__)))
        api_submit('/api/nodes', data, method='put')


def search_nodes(args):
    """Search for nodes and perform optional assignment
       actions."""

    log.info('action_command is: {0}'.format(args.action_command))
    log.info('object_type is: {0}'.format(args.object_type))

    # FIXME: Ths is going to get ugly real fast
#    actions = ['set_tags', 'set_status', 'set_node_groups', 'del_node_groups']
#    for a in actions:
#        foo = getattr(args, a)()
#        print "FOO IS: ", foo
#        if foo:
#           globals()[foo](args) 
    if args.set_tags:
        set_tag(args)
    if args.set_status:
        results = _search(args)
        if results:
            r_names = []
            for n in results:
                r_names.append(n['node_name'])
            if ask_yes_no("We are ready to update the following nodes: \n{0}\n Continue?".format("\n".join(r_names)), args.answer_yes):
                _set_status(args, results)
    if args.set_node_groups:
        results = _search(args)
        if results:
            r_names = []
            for n in results:
                r_names.append(n['node_name'])
            if ask_yes_no("We are ready to update the following nodes: \n{0}\n Continue?".format("\n".join(r_names)), args.answer_yes):
                _assign_node_groups(args, results)
    if args.del_node_groups:
        results = _search(args)
        if results:
            r_names = []
            for n in results:
                r_names.append(n['node_name'])
            if ask_yes_no("We are ready to update the following nodes: \n{0}\n Continue?".format("\n".join(r_names)), args.answer_yes):
                _deassign_node_groups(args, results)

    if not any((args.set_tags,
                args.set_status,
                args.set_node_groups,
                args.del_node_groups)):

        results = _search(args)

        # FIXME: Doesn't work beyond the top level for individual fields
        if args.fields:
            for r in results:
                print '- {0}\n'.format(r['node_name'])
#                print res['status']['status_name']
                if args.fields == 'all':
                    # FIXME: Is this really the best way?
                    # This produces ugly formatting
                    # print(yaml.safe_dump(r, encoding='utf-8', allow_unicode=True))
                    #print(yaml.dump(r, default_flow_style=False))
                    c = convert(r)
#                    f = (yaml.dump(c, default_flow_style=False, encoding='utf-8', allow_unicode=True, indent=2))
#                    print textwrap.fill(f, initial_indent='', subsequent_indent='    ')
                    print(yaml.dump(c, default_flow_style=False, encoding='utf-8', allow_unicode=True, indent=2))

#                    print json.dumps(r, default=lambda o: o.__dict__, sort_keys=True,
#                                     indent=2, separators=(',', ': ')).

                    #for f in r.keys():
                    #    if f == 'node_name':
                    #        continue
                    #    print '    {0}: {1}'.format(f, r[f])
                else:
                    for f in list(args.fields.split(",")):
                        if f == 'node_name':
                            continue
                        print '    {0}: {1}'.format(f, r[f])
        # Default to returning just the node name
        else:
            for r in results:
                print r['node_name']


def convert(data):
    """Helper method to format output. (might not be final solution)"""

    if isinstance(data, basestring):
        return str(data)
    elif isinstance(data, collections.Mapping):
        return dict(map(convert, data.iteritems()))
    elif isinstance(data, collections.Iterable):
        return type(data)(map(convert, data))
    else:
        return data

def _set_status(args, nodes):
    """Set the status of one or more nodes."""

    log.info('action_command is: {0}'.format(args.action_command))
    log.info('object_type is: {0}'.format(args.object_type))

    data = {'status_name': args.set_status}
    status = api_submit('/api/statuses', data, method='get_params')
     
    data = {'status_id': status['status_id']}

    for n in nodes:
        log.info('Setting status node={0},status={1}'.format(n['node_name'], status['status_name']))
        api_submit('/api/nodes/{0}'.format(n['node_id']), data, method='put')


# FIXME: next two are very similar. can combine?
def _assign_node_groups(args, nodes):
    """Assign node_groups to one or more nodes."""

    log.info('action_command is: {0}'.format(args.action_command))
    log.info('object_type is: {0}'.format(args.object_type))

    node_groups = []
    for ng in args.set_node_groups.split(','):
        data = {'node_group_name': ng}
        r = api_submit('/api/node_groups', data, method='get_params')
        if r:
            node_groups.append(r[0])

    for n in nodes:
        for ng in node_groups:
            log.info('Assigning node_group={0} to node={1}'.format(ng['node_group_name'], n['node_name']))
            data = {'node_id': n['node_id'],
                    'node_group_id': ng['node_group_id']}
            api_submit('/api/node_group_assignments', data, method='put')


def _deassign_node_groups(args, nodes):
    """Remove node_groups from one or more nodes."""

    log.info('action_command is: {0}'.format(args.action_command))
    log.info('object_type is: {0}'.format(args.object_type))

    node_groups = []
    for ng in args.del_node_groups.split(','):
        data = {'node_group_name': ng}
        r = api_submit('/api/node_groups', data, method='get_params')
        if r:
            node_groups.append(r[0])

    for n in nodes:
        for ng in node_groups:
            log.info('Removing assignment of node_group={0} from node={1}'.format(ng['node_group_name'], n['node_name']))
            data = {'node_id': n['node_id'],
                    'node_group_id': ng['node_group_id']}
            api_submit('/api/node_group_assignments', data, method='delete')


def create_nodes(args):
    """Create a new node."""

    # FIXME: Support unique_id, hardware_profile, and operating_system?
    log.info('action_command is: {0}'.format(args.action_command))
    log.info('object_type is: {0}'.format(args.object_type))

    data = {'register': False,
            'node_name': args.node_name,
            'node_status_id': args.status_id,
           }

    log.info('Creating node node_name={0},status_id={1}'.format(args.node_name, args.status_id))
    api_submit('/api/{0}'.format(args.object_type), data, method='put')


def delete_nodes(args):

    log.info('action_command is: {0}'.format(args.action_command))
    log.info('object_type is: {0}'.format(args.object_type))


## NODE_GROUPS
def search_node_groups(args):
    """Search for node groups and perform optional assignment
       actions."""

    log.info('action_command is: {0}'.format(args.action_command))
    log.info('object_type is: {0}'.format(args.object_type))

    if args.set_tags:
        set_tag(args)
 
    # switch to any if there's more than one
    if not args.set_tags:

        results = _search(args)

        if args.fields:
            for r in results:
                print '- {0}'.format(r['node_group_name'])
                if args.fields == 'all':
                    for f in r.keys():
                        if f == 'node_group_name':
                            continue
                        print '    {0}: {1}'.format(f, r[f])
                else:
                    for f in list(args.fields.split(",")):
                        if f == 'node_group_name':
                            continue
                        print '    {0}: {1}'.format(f, r[f])
        # Default to returning just the node_group name
        else:
            for r in results:
                print r['node_group_name']


def create_node_groups(args):
    """Create a new node_group."""

    log.info('action_command is: {0}'.format(args.action_command))
    log.info('object_type is: {0}'.format(args.object_type))

    data = {'node_group_name': args.node_group_name,
            'node_group_owner': args.node_group_owner,
            'node_group_description': args.node_group_description,
           }

    log.info('Creating node_group node_group_name={0},node_group_owner={1},node_group_description={2}'.format(args.node_group_name, args.node_group_owner, args.node_group_description))
    api_submit('/api/{0}'.format(args.object_type), data, method='put')


def delete_node_groups(args):
    """Delete an existing node_group."""

    # FIXME: Support name and id or ?
    log.info('action_command is: {0}'.format(args.action_command))
    log.info('object_type is: {0}'.format(args.object_type))

    args.search = 'node_group_name={0}'.format(args.node_group_name)
    results = _search(args)

    if results:
        r_names = []
        for n in results:
            r_names.append(n['node_group_name'])

        if ask_yes_no("We are ready to delete the following {0}: \n{1}\n Continue?".format(args.object_type, "\n".join(r_names)), args.answer_yes):
            for n in results:
                log.info('Deleting node_group_name={0}'.format(n['node_group_name']))
                data = {'node_group_id': n['node_group_id']}
                # FIXME: name? id? both?
                api_submit('/api/{0}/{1}'.format(args.object_type, n['node_group_id']), data, method='delete')
    else:
        log.info('No results found')


def _search(args):

    log.info('Searching for {0}'.format(args.object_type))
    log.info('action_command is: {0}'.format(args.action_command))

    search_terms = list(args.search.split(","))
    data = dict(u.split("=") for u in search_terms)
    data['exact_get'] = args.exact_get
    log.info('data is: {0}'.format(data))

    api_endpoint = '/api/{0}'.format(args.object_type)
    r = api_submit(api_endpoint, data, method='get_params')
    return r


def _parse_args():

    pp = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter, add_help=False)
    mp = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter, description='Arsenal CLI')

    mp.add_argument('--config',
                   '-c',
                   dest='config_file',
                   help='Configuration file to use',
                   default='/app/arsenal/conf/arsenal.conf')
    mp.add_argument('--kookie',
                   '-k',
                   dest='cookie_file',
                   help='Cookie file to use for auth.',
                   default=os.environ['HOME'] + '/.arsenal_cookie')
    mp.add_argument('--login',
                   '-l',
                   help='Login name making the request.',
                   default=os.environ['USER'])
    mp.add_argument('--secrets',
                   '-s',
                   dest='secrets_config_file',
                   help='Secret config file to use.',
                   default='/app/secrets/arsenal.conf')
    mp.add_argument('--server',
                   dest='api_host',
                   help='arsenal server to use. Overrides config file (FIXME: not yet)',
                   default=None)
    mp.add_argument('--quiet',
                   '-q',
                   action='store_true',
                   help='Only log errors.',
                   default=None)
    mp.add_argument('--verbose',
                   '-v',
                   action='store_true',
                   help='Log debug messages to the log file',
                   default=None)
    mp.add_argument('--yes',
                    '-y',
                    action='store_true',
                    dest="answer_yes",
                    help='answer yes to prompts.')
    

    otsp = mp.add_subparsers(title="Object Type",
                             dest="object_type")

    ### REGISTER
    # This is a bit of a cheat since technically it's not an object type.
    # Putting it at the top level since it is the primary command.
    r_help = ("Register this node to the server.\n\n")
    rotp = otsp.add_parser("register",
                           description=r_help,
                           help=r_help,
                           parents=[pp])
    rotp.set_defaults(func=_register)

    ### NODES
    ### nodes object_type parser (notp)
    n_help = ("Perform actions on the nodes object_type. Use the search \n"
              "action to perform assignment actions such as tagging, \n"
              "assigning node_groups, and setting status.\n\n")
    notp = otsp.add_parser("nodes",
                           description=n_help,
                           help=n_help,
                           parents=[pp])
    
    # nodes action sub-parser (nasp)
    nasp = notp.add_subparsers(title="Actions",
                               dest="action_command")

    # nodes search subcommand (nssc)
    nssc = nasp.add_parser("search",
                           help="Search for node objects and optionally act upon the results.",
                           parents=[pp])
    nssc.add_argument('--fields',
                      '-f',
                      dest='fields',
                      help='Comma separated list of fields to display, or \'all\' for all fields.',
                      default=None)
    nssc.add_argument('--exact',
                      action='store_true',
                      dest="exact_get",
                      help='Exact match search terms.')

    # nodes assignment action argument group (ansqg)
    ansag = nssc.add_argument_group('Assignment Actions')

    ansag.add_argument('--status',
                       dest="set_status",
                       help='status to assign to the search results.')
    ansag.add_argument('--tag',
                       dest="set_tags",
                       help='Comma separated list of key=value pairs to tag to the search results.')
    ansag.add_argument('--del_tag',
                       dest="del_tags",
                       help='Comma separated list of key=value pairs to un-tag from the search results.')
    ansag.add_argument('--node_groups',
                       dest="set_node_groups",
                       help='Comma separated list of node_groups to assign to the search results.')
    ansag.add_argument('--del_node_groups',
                       dest="del_node_groups",
                       help='Comma separated list of node_groups to un-assign from the search results.')
    nssc.add_argument('search',
                      default=None,
                      metavar='search_terms',
                      help='Comma separated list of key=value pairs to search for.')
    nssc.set_defaults(func=search_nodes)

    # nodes create subcommand (ncsc)
    ncsc = nasp.add_parser("create",
                           description="Create node objects.",
                           help="Create node objects.",
                           parents=[pp])

    # nodes required argument group (rncag)
    rncag = ncsc.add_argument_group('required arguments')

    ncsc.add_argument('--unique_id', '-u',
                      dest="unique_id",
                      help='unique_id to assign.')
    # FIXME: Should this be required?
    ncsc.add_argument('--hardware_profile_id', '-hp',
                      dest="hardware_profile_id",
                      help='hardware_profile_id to assign.')
    # FIXME: Should this be required?
    ncsc.add_argument('--operating_system_id', '-os',
                      dest="operating_system_id",
                      help='operating_system_id to assign.')
    rncag.add_argument('--name', '-n',
                       required=True,
                       dest="node_name",
                       help='node_name to create')
    rncag.add_argument('--status_id', '-s',
                       required=True,
                       dest="status_id",
                       help='status_id to assign.')
    rncag.set_defaults(func=create_nodes)

    # nodes delete subcommand (ndsc)
    ndsc = nasp.add_parser("delete",
                           help="Delete node objects.",
                           parents=[pp])
    ndsc.add_argument('search',
                      default=None,
                      metavar='search_terms',
                      help='Comma separated list of key=value pairs to search for.')
    ndsc.set_defaults(func=delete_nodes)

    ### NODE_GROUPS
    ### node_groups object_type parser (ngotp)
    ng_help = ("Perform actions on the node_groups object_type. Use the \n"
               "search action to perform assignment actions such as tagging.\n\n")
    ngotp = otsp.add_parser("node_groups",
                            description=ng_help,
                            help=ng_help,
                            parents=[pp])

    # node_groups action sub-parser (ngasp)
    ngasp = ngotp.add_subparsers(title="Available actions",
                                 dest="action_command")
    # node_groups search subcommand (ngssc)
    ngssc = ngasp.add_parser("search",
                             help="Search for node_group objects and optionally act upon the results.",
                             parents=[pp])
    ngssc.add_argument('--fields',
                       '-f',
                       dest='fields',
                       help='Comma separated list of fields to display, or \'all\' for all fields.',
                       default=None)
    ngssc.add_argument('--exact',
                       action='store_true',
                       dest="exact_get",
                       help='Exact match search terms.')

    # node_groups assignment action argument group (angsag)
    angsag = ngssc.add_argument_group('Assignment Actions')

    angsag.add_argument('--tag',
                        dest="set_tags",
                        help='Comma separated list of key=value pairs to tag to the node_group.')
    ngssc.add_argument('search',
                       default=None,
                       metavar='search_terms',
                       help='Comma separated list of key=value pairs to search for.')
    ngssc.set_defaults(func=search_node_groups)

    # node_groups create subcommand (ngcsc)
    ngcsc = ngasp.add_parser("create",
                             help="Create node_group objects.",
                             parents=[pp])

    # required node_group greate argument group (rngcag)
    rngcag = ngcsc.add_argument_group('required arguments')

    rngcag.add_argument('--name', '-n',
                        required=True,
                        dest="node_group_name",
                        help='node_group_name to create.')
    rngcag.add_argument('--description', '-d',
                        required=True,
                        dest="node_group_description",
                        help='node_group_description to assign.')
    rngcag.add_argument('--owner', '-o',
                        required=True,
                        dest="node_group_owner",
                        help='node_group_owner to assign.')
    rngcag.set_defaults(func=create_node_groups)

    # node_groups delete subcommand (ngdsc)
    ngdsc = ngasp.add_parser("delete",
                             help="Delete node_group objects.",
                             parents=[pp])
    # required node_group delete argument group (rngdag)
    rngdag = ngdsc.add_argument_group('required arguments')

    rngdag.add_argument('--name', '-n',
                        required=True,
                        dest="node_group_name",
                        help='node_group_name to delete.')
    ngdsc.set_defaults(func=delete_node_groups)

    return mp.parse_args()   


def main():

    # parse the args
    args = _parse_args()

    # Get the config
    config = ConfigParser.ConfigParser()
    config.read(args.config_file)
    secrets_config = ConfigParser.ConfigParser()
    secrets_config.read(args.secrets_config_file)
    # Globalizing these. Otherwise will be passing them all over the
    # place for no reason.
    global api_host
    global api_protocol
    global verify_ssl
    global ca_bundle_file
    global login
    global cookie_file
    global kaboom_password
    # command line first, config file second.
    api_host = args.api_host if args.api_host else config.get('main', 'api.host')
    api_protocol = config.get('main', 'api.protocol')
    ca_bundle_file = config.get('main', 'ca.bundle.file')
    verify_ssl = bool(config.get('main', 'verify.ssl'))
    log_file = config.get('main', 'log.file')
    login = args.login
    cookie_file = args.cookie_file
    kaboom_password = secrets_config.get('main', 'kaboom.password')

    if args.verbose:
        log_level = logging.DEBUG
    elif args.quiet:
        log_level = logging.ERROR
    else:
        log_level = logging.INFO

    # Set up logging to file
    logging.basicConfig(level=log_level,
                        format='%(asctime)s %(levelname)-8s- %(message)s',
                        datefmt='%Y-%m-%d %H:%M:%S',
                        filename=log_file,
                        filemode='a')

    console = logging.StreamHandler()
    console.setLevel(log_level)
    formatter = logging.Formatter('%(levelname)-8s- %(message)s')
    console.setFormatter(formatter)
    logging.getLogger('').addHandler(console)

    if args.verbose:
        log.info('Debug messages are being written to the log file : %s'
                     % log_file)
    log.info('Using server: %s'
                 % api_host)

    if login == 'kaboom':
    
        if not os.geteuid() == 0:
            log.error('Login {0} must run as root.'.format(login))
            sys.exit(1)

        # FIXME: Will need os checking here
        cookie_file = '/root/.arsenal_cookie'

    # call whatever function was selected
    args.func(args)

#        print json.dumps(data, default=lambda o: o.__dict__, sort_keys=True, indent=4, separators=(',', ': '))

if __name__ == '__main__':
    main()
