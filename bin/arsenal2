#!/usr/bin/python
#
#  Copyright 2015 CityGrid Media, LLC
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
import os
import sys
import argparse
import logging
import yaml
import types
import collections

from arsenalclientlib import Arsenal
from arsenalclientlib.node import Node
from arsenalclientlib.node_group import NodeGroup
from arsenalclientlib.tag import Tag

log = logging.getLogger(__name__)


def _register(args):
    """Register a node."""

    node = Node()
    node.register()


def _search_nodes(args):
    """Search for nodes and perform optional assignment
       actions."""

    node = Node()
    results = node.search_nodes(args)

    if results:
        r_names = []
        # FIXME: Crappy duplication
#        actions = ['set_tags', 'set_status', 'set_node_groups', 'del_node_groups']
#        for a in actions:
#            foo = getattr(args, a)()
#            print "FOO IS: ", foo
#            if foo:
#               globals()[foo](args)

        if args.set_status:
            for n in results:
                r_names.append('{0}: {1}'.format(n['node_name'], n['unique_id']))
            if ask_yes_no("We are ready to update the following nodes: \n{0}\n Continue?".format("\n".join(r_names)), args.answer_yes):
                node.set_status(args.set_status, results)

        elif args.set_tags:
            for n in results:
                r_names.append('{0}: {1}'.format(n['node_name'], n['unique_id']))
            if ask_yes_no("We are ready to update the following nodes: \n{0}\n Continue?".format("\n".join(r_names)), args.answer_yes):
                node.manage_tag_assignments(args, results, 'node')

        elif args.del_tags:
            for n in results:
                r_names.append('{0}: {1}'.format(n['node_name'], n['unique_id']))
            if ask_yes_no("We are ready to update the following nodes: \n{0}\n Continue?".format("\n".join(r_names)), args.answer_yes):
                # FIXME: don't love this
                node.manage_tag_assignments(args, results, 'node', 'delete')

        elif any((args.set_node_groups,
                 args.del_node_groups)):
            for n in results:
                r_names.append('{0}: {1}'.format(n['node_name'], n['unique_id']))
            if ask_yes_no("We are ready to update the following nodes: \n{0}\n Continue?".format("\n".join(r_names)), args.answer_yes):
                node.manage_node_group_assignments(args, results)

        elif any((args.set_hypervisor,
                 args.del_hypervisor)):
            for n in results:
                r_names.append('{0}: {1}'.format(n['node_name'], n['unique_id']))
            if ask_yes_no("We are ready to update the following nodes: \n{0}\n Continue?".format("\n".join(r_names)), args.answer_yes):
                node.manage_hypervisor_assignments(args, results)

        else:
            if args.fields:
                for r in results:
                    # FIXME: formatting stinks
                    print '- {0}\n'.format(r['node_name'])
                    if args.fields == 'all':
                        c = convert(r)
                        print(yaml.dump(c, default_flow_style=False, encoding='utf-8', allow_unicode=True, indent=2))

                    else:
                        for f in list(args.fields.split(",")):
                            if f == 'node_name':
                                continue
                            if type(r[f]) is types.ListType:
                                print '{0}: \n{1}'.format(f, yaml.safe_dump(r[f], encoding='utf-8', allow_unicode=True))
                            else:
                                print '    {0}: {1}'.format(f, r[f])
            # Default to returning just the node name
            else:
                for r in results:
                    print r['node_name']


def _create_node(args):
    """Create a node."""

    node = Node()
    node.create_node(args)


def _delete_nodes(args):
    """Delete a node."""

    node = Node()
    node.delete_nodes(args)


def _search_node_groups(args):
    """Search for node_groups and perform optional assignment
       actions."""

    node_group = NodeGroup()
    results = node_group.search_node_groups(args)

    if results:

        if any((args.set_tags,
            args.del_tags)):
            r_names = []

            for ng in results:
                r_names.append('node_group_name={0},node_group_id={1}'.format(ng['node_group_name'], ng['node_group_id']))
            if ask_yes_no("We are ready to update the following node_groups: \n{0}\n Continue?".format("\n".join(r_names)), args.answer_yes):
                api_action = 'set'
                if args.del_tags:
                    api_action = 'delete'
                node_group.manage_tag_assignments(args, results, 'node_group', api_action)

        else:
            if args.fields:
                for r in results:
                    print '- {0}'.format(r['node_group_name'])
                    #FIXME: gross output, duplicate code
                    if args.fields == 'all':
                        for f in r.keys():
                            if f == 'node_group_name':
                                continue
                            if type(r[f]) is types.ListType:
                                print '{0}: \n{1}'.format(f, yaml.safe_dump(r[f], encoding='utf-8', allow_unicode=True))
                            else:
                                print '    {0}: {1}'.format(f, r[f])
                    else:
                        for f in list(args.fields.split(",")):
                            if f == 'node_group_name':
                                continue
                            if type(r[f]) is types.ListType:
                                print '{0}: \n{1}'.format(f, yaml.safe_dump(r[f], encoding='utf-8', allow_unicode=True))
                            else:
                                print '    {0}: {1}'.format(f, r[f])

            # Default to returning just the node_group name
            else:
                for r in results:
                    print r['node_group_name']


def _create_node_groups(args):
    """Create a node_group"""

    node_group = NodeGroup()
    node_group.create_node_groups(args)


def _delete_node_groups(args):
    """Delete a node_group"""

    node_group = NodeGroup()
    node_group.delete_node_groups(args)


def _search_tags(args):
    """Search for tags"""

    tag = Tag()
    results = tag.search_tags(args)

    if results:

        # FIXME: this doesn't exist yet. Would need to do a reverse search on nodes and node groups. Is it worth it, or do we just tag things from their respective object type?
        if args.set_tags:
            set_tag(args)

        else:

            if args.fields:
                for r in results:
                    print '- {0}'.format(r['tag_name'])
                    if args.fields == 'all':
                        for f in r.keys():
                            if f == 'tag_name':
                                continue
                            print '    {0}: {1}'.format(f, r[f])
                    else:
                        for f in list(args.fields.split(",")):
                            if f == 'tag_name':
                                continue
                            print '    {0}: {1}'.format(f, r[f])
            # Default to returning just the tag name
            else:
                for r in results:
                    print '{0}={1}'.format(r['tag_name'], r['tag_value'])


def _create_tags(args):
    """Create a tag"""

    tag = Tag()
    tag.create_tags(args)


def _delete_tags(args):
    """Delete a tag"""

    tag = Tag()
    tag.delete_tags(args)


def gen_help(help_type):
    """Generte the list of searchable terms for help"""

    terms = {
        'nodes_search': [ 'node_id', 'node_name', 'unique_id', 'status_id',
                          'status', 'hardware_profile_id', 'hardware_profile',
                          'operating_system_id', 'operating_system', 'uptime',
                          'node_groups', 'created', 'updated', 'updated_by',
        ],
        'node_groups_search': [ 'node_group_id', 'node_group_name',
                                'node_group_owner', 'description',
        ],
        'tags_search': [ 'tag_id', 'tag_name', 'tag_value',
        ],
        'hypervisor_vm_assignments_search': [ 'parent_id', 'child_id',
        ],
    }

    return '[ {0} ]'.format(', '.join(sorted(terms[help_type])))


def ask_yes_no(question, answer_yes=None, default='no'):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """

    if answer_yes:
        return True

    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")


def convert(data):
    """Helper method to format output. (might not be final solution)"""

    if isinstance(data, basestring):
        return str(data)
    elif isinstance(data, collections.Mapping):
        return dict(map(convert, data.iteritems()))
    elif isinstance(data, collections.Iterable):
        return type(data)(map(convert, data))
    else:
        return data


def _parse_args():
    """Parse all the command line arguments."""

    pp = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter, add_help=False)
    mp = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter, description='Arsenal CLI')

    mp.add_argument('--conf',
                   '-c',
                   dest='conf_file',
                   help='Configuration file to use',
                   default='/app/arsenal/conf/arsenal.conf')
    mp.add_argument('--kookie',
                   '-k',
                   dest='cookie_file',
                   help='Cookie file to use for auth.',
                   default=os.environ['HOME'] + '/.arsenal_cookie')
    mp.add_argument('--login',
                   '-l',
                   help='Login name making the request.',
                   default=os.environ['USER'])
    mp.add_argument('--secrets',
                   '-s',
                   dest='secrets_conf_file',
                   help='Secret configuration file to use.',
                   default=None)
    mp.add_argument('--server',
                   dest='api_host',
                   help='arsenal server to use. Overrides the setting in the config file.',
                   default=None)
    mp.add_argument('--quiet',
                   '-q',
                   action='store_true',
                   help='Only log errors.',
                   default=None)
    mp.add_argument('--verbose',
                   '-v',
                   action='store_true',
                   help='Increased logging verbosity',
                   default=None)
    mp.add_argument('--write_log',
                   '-w',
                   action='store_true',
                   help='Log messages to the log file',
                   default=None)
    mp.add_argument('--yes',
                    '-y',
                    action='store_true',
                    dest="answer_yes",
                    help='answer yes to prompts.')
    

    # FIXME: Really need a generator for all this. Perhaps one that can take json as an input?
    otsp = mp.add_subparsers(title="Object Type",
                             dest="object_type")

    ### REGISTER
    # This is a bit of a cheat since technically it's not an object type.
    # Putting it at the top level since it is the primary command.
    r_help = ("Register this node to the server.\n\n")
    rotp = otsp.add_parser("register",
                           description=r_help,
                           help=r_help,
                           parents=[pp])
    rotp.set_defaults(func=_register)

    ### NODES
    ### nodes object_type parser (notp)
    n_help = ("Perform actions on the nodes object_type. Use the search \n"
              "action to perform assignment actions such as tagging, \n"
              "assigning node_groups, and setting status.\n\n")
    notp = otsp.add_parser("nodes",
                           description=n_help,
                           help=n_help,
                           parents=[pp])
    
    # nodes action sub-parser (nasp)
    nasp = notp.add_subparsers(title="Actions",
                               dest="action_command")

    # nodes search subcommand (nssc)
    nssc = nasp.add_parser("search",
                           help="Search for node objects and optionally act upon the results.",
                           parents=[pp])
    nssc.add_argument('--fields',
                      '-f',
                      dest='fields',
                      help='Comma separated list of fields to display, or \'all\' for all fields.',
                      default=None)
    nssc.add_argument('--exact',
                      action='store_true',
                      dest="exact_get",
                      default=None,
                      help='Exact match search terms.')

    # nodes assignment action argument group (ansqg)
    ansag = nssc.add_argument_group('Assignment Actions')

    ansag.add_argument('--status',
                       dest="set_status",
                       help='status to assign to the search results.')
    ansag.add_argument('--tag',
                       dest="set_tags",
                       help='Comma separated list of key=value pairs to tag to the search results.')
    ansag.add_argument('--del_tag',
                       dest="del_tags",
                       help='Comma separated list of key=value pairs to un-tag from the search results.')
    ansag.add_argument('--node_groups',
                       dest="set_node_groups",
                       help='Comma separated list of node_groups to assign to the search results.')
    ansag.add_argument('--del_node_groups',
                       dest="del_node_groups",
                       help='Comma separated list of node_groups to un-assign from the search results.')
    ansag.add_argument('--hypervisor',
                       dest="set_hypervisor",
                       help='The unique_id of the hypervisor that you wish to assign to the search results.')
    ansag.add_argument('--del_hypervisor',
                       dest="del_hypervisor",
                       help='The unique_id of the hypervisor that you wish to de-assign from the search results.')
    nssc.add_argument('search',
                      default=None,
                      metavar='search_terms',
                      help='Comma separated list of key=value pairs to search for.\n {0}'.format(gen_help('nodes_search')))
    nssc.set_defaults(func=_search_nodes)

    # nodes create subcommand (ncsc)
    ncsc = nasp.add_parser("create",
                           description="Create node objects.",
                           help="Create node objects.",
                           parents=[pp])

    # nodes required argument group (rncag)
    rncag = ncsc.add_argument_group('required arguments')

    ncsc.add_argument('--hardware_profile_id', '-hp',
                      dest="hardware_profile_id",
                      help='hardware_profile_id to assign.')
    ncsc.add_argument('--operating_system_id', '-os',
                      dest="operating_system_id",
                      help='operating_system_id to assign.')
    rncag.add_argument('--name', '-n',
                       required=True,
                       dest="node_name",
                       help='node_name to create')
    rncag.add_argument('--unique_id', '-u',
                       required=True,
                       dest="unique_id",
                       help='unique_id to assign.')
    rncag.add_argument('--status_id', '-s',
                       required=True,
                       dest="status_id",
                       help='status_id to assign.')
    rncag.set_defaults(func=_create_node)

    # nodes delete subcommand (ndsc)
    ndsc = nasp.add_parser("delete",
                           help="Delete node objects. At least one of name, unique_id, or id is required",
                           parents=[pp])
    ndsc.add_argument('--name', '-n',
                      dest="node_name",
                      help='node_name to delete.')
    ndsc.add_argument('--unique_id', '-u',
                      dest="unique_id",
                      help='unique_id to delete.')
    ndsc.add_argument('--id', '-i',
                      dest="node_id",
                      help='node_id to delete.')
    ndsc.set_defaults(func=_delete_nodes)

    ### NODE_GROUPS
    ### node_groups object_type parser (ngotp)
    ng_help = ("Perform actions on the node_groups object_type. Use the \n"
               "search action to perform assignment actions such as tagging.\n\n")
    ngotp = otsp.add_parser("node_groups",
                            description=ng_help,
                            help=ng_help,
                            parents=[pp])

    # node_groups action sub-parser (ngasp)
    ngasp = ngotp.add_subparsers(title="Available actions",
                                 dest="action_command")
    # node_groups search subcommand (ngssc)
    ngssc = ngasp.add_parser("search",
                             help="Search for node_group objects and optionally act upon the results.",
                             parents=[pp])
    ngssc.add_argument('--fields',
                       '-f',
                       dest='fields',
                       help='Comma separated list of fields to display, or \'all\' for all fields.',
                       default=None)
    ngssc.add_argument('--exact',
                       action='store_true',
                       dest="exact_get",
                       default=None,
                       help='Exact match search terms.')

    # node_groups assignment action argument group (angsag)
    angsag = ngssc.add_argument_group('Assignment Actions')

    angsag.add_argument('--tag',
                        dest="set_tags",
                        help='Comma separated list of key=value pairs to tag to the node_group.')
    angsag.add_argument('--del_tag',
                        dest="del_tags",
                        help='Comma separated list of key=value pairs to un-tag from the search results.')
    ngssc.add_argument('search',
                       default=None,
                       metavar='search_terms',
                       help='Comma separated list of key=value pairs to search for.\n {0}'.format(gen_help('node_groups_search')))
    ngssc.set_defaults(func=_search_node_groups)

    # node_groups create subcommand (ngcsc)
    ngcsc = ngasp.add_parser("create",
                             help="Create node_group objects.",
                             parents=[pp])

    # required node_group create argument group (rngcag)
    rngcag = ngcsc.add_argument_group('required arguments')

    rngcag.add_argument('--name', '-n',
                        required=True,
                        dest="node_group_name",
                        help='node_group_name to create.')
    rngcag.add_argument('--description', '-d',
                        required=True,
                        dest="node_group_description",
                        help='node_group_description to assign.')
    rngcag.add_argument('--owner', '-o',
                        required=True,
                        dest="node_group_owner",
                        help='node_group_owner to assign.')
    rngcag.set_defaults(func=_create_node_groups)

    # node_groups delete subcommand (ngdsc)
    ngdsc = ngasp.add_parser("delete",
                             help="Delete node_group objects.",
                             parents=[pp])
    # required node_group delete argument group (rngdag)
    rngdag = ngdsc.add_argument_group('required arguments')

    rngdag.add_argument('--name', '-n',
                        required=True,
                        dest="node_group_name",
                        help='node_group_name to delete.')
    ngdsc.set_defaults(func=_delete_node_groups)

    ### TAGS
    ### tags object_type parser (totp)
    t_help = ("Perform actions on the tags object_type. Use the search\n"
               "action to perform assignment actions such as tagging.\n\n")
    totp = otsp.add_parser("tags",
                            description=t_help,
                            help=t_help,
                            parents=[pp])

    # tags action sub-parser (tasp)
    tasp = totp.add_subparsers(title="Available actions",
                               dest="action_command")
    # tags search subcommand (tssc)
    tssc = tasp.add_parser("search",
                           help="Search for tags objects and optionally act upon the results.",
                           parents=[pp])
    tssc.add_argument('--fields',
                      '-f',
                      dest='fields',
                      help='Comma separated list of fields to display, or \'all\' for all fields.',
                      default=None)
    tssc.add_argument('--exact',
                      action='store_true',
                      dest="exact_get",
                      default=None,
                      help='Exact match search terms.')

    # FIXME: do we want to 'reverse' tag? i.e. select a tag and assign it many nodes or nodegroups?
    # tags assignment action argument group (atsag)
    atsag = tssc.add_argument_group('Assignment Actions')

    atsag.add_argument('--tag',
                        dest="set_tags",
                        help='Comma separated list of key=value pairs to tag to the node_group.')
    tssc.add_argument('search',
                      default=None,
                      metavar='search_terms',
                      help='Comma separated list of key=value pairs to search for.\n {0}'.format(gen_help('tags_search')))
    atsag.set_defaults(func=_search_tags)

    # tags create subcommand (tcsc)
    tcsc = tasp.add_parser("create",
                           help="Create tag objects.",
                           parents=[pp])

    # required tag create argument group (rtcag)
    rtcag = tcsc.add_argument_group('required arguments')

    rtcag.add_argument('--name', '-n',
                        required=True,
                        dest="tag_name",
                        help='tag_name to create.')
    rtcag.add_argument('--value',
                        required=True,
                        dest="tag_value",
                        help='tag_value to assign to the name.')
    rtcag.set_defaults(func=_create_tags)

    # tags delete subcommand (tdsc)
    tdsc = tasp.add_parser("delete",
                           help="Delete tag objects.",
                           parents=[pp])

    # required tag delete argument group (rtdag)
    rtdag = tdsc.add_argument_group('required arguments')

    rtdag.add_argument('--name', '-n',
                        required=True,
                        dest="tag_name",
                        help='tag_name to delete.')
    rtdag.add_argument('--value',
                        required=True,
                        dest="tag_value",
                        help='tag_value to delete.')
    tdsc.set_defaults(func=_delete_tags)

    args = mp.parse_args()

    if (args.object_type=='nodes' and args.action_command=='delete'):
        if not (args.node_name or args.unique_id or args.node_id):
            ndsc.error('Too few parameters, please specify at least one of --name, --unique_id or --id')

    return args


def main():
    """The earth-shattering kaboom"""

    # parse the args
    args = _parse_args()

    if args.secrets_conf_file:
        Arsenal(args.conf_file, args.secrets_conf_file, args)
    else:
        Arsenal(args.conf_file, args=args)

    # call whatever function was selected
    args.func(args)

if __name__ == '__main__':
    main()
